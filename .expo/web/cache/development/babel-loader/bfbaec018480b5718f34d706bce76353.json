{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initialUpdaterRun = initialUpdaterRun;\nexports.transform = transform;\nexports.transformAnimation = transformAnimation;\nexports.decorateAnimation = decorateAnimation;\nexports.defineAnimation = defineAnimation;\nexports.cancelAnimation = cancelAnimation;\nexports.withTiming = withTiming;\nexports.withSpring = withSpring;\nexports.withDecay = withDecay;\nexports.withDelay = withDelay;\nexports.withSequence = withSequence;\nexports.withRepeat = withRepeat;\nexports.delay = delay;\nexports.repeat = repeat;\nexports.loop = loop;\nexports.sequence = sequence;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _Easing = require(\"./Easing\");\n\nvar _Colors = require(\"./Colors\");\n\nvar _NativeReanimated = _interopRequireDefault(require(\"./NativeReanimated\"));\n\nvar IN_STYLE_UPDATER = false;\n\nfunction initialUpdaterRun(updater) {\n  IN_STYLE_UPDATER = true;\n  var result = updater();\n  IN_STYLE_UPDATER = false;\n  return result;\n}\n\nfunction transform(value, handler) {\n  'worklet';\n\n  if (value === undefined) {\n    return undefined;\n  }\n\n  if (typeof value === 'string') {\n    var match = value.match(/([A-Za-z]*)(-?\\d*\\.?\\d*)([A-Za-z%]*)/);\n    var prefix = match[1];\n    var suffix = match[3];\n    var number = match[2];\n    handler.__prefix = prefix;\n    handler.__suffix = suffix;\n    return parseFloat(number);\n  }\n\n  if (handler.__prefix === undefined) {\n    return value;\n  }\n\n  return handler.__prefix + value + handler.__suffix;\n}\n\nfunction transformAnimation(animation) {\n  'worklet';\n\n  if (!animation) {\n    return;\n  }\n\n  animation.toValue = transform(animation.toValue, animation);\n  animation.current = transform(animation.current, animation);\n  animation.startValue = transform(animation.startValue, animation);\n}\n\nfunction decorateAnimation(animation) {\n  'worklet';\n\n  if (animation.isHigherOrder) {\n    return;\n  }\n\n  var baseOnStart = animation.onStart;\n  var baseOnFrame = animation.onFrame;\n  var animationCopy = (0, _extends2.default)({}, animation);\n  delete animationCopy.callback;\n\n  var prefNumberSuffOnStart = function prefNumberSuffOnStart(animation, value, timestamp, previousAnimation) {\n    var val = transform(value, animation);\n    transformAnimation(animation);\n    if (previousAnimation !== animation) transformAnimation(previousAnimation);\n    baseOnStart(animation, val, timestamp, previousAnimation);\n    transformAnimation(animation);\n    if (previousAnimation !== animation) transformAnimation(previousAnimation);\n  };\n\n  var prefNumberSuffOnFrame = function prefNumberSuffOnFrame(animation, timestamp) {\n    transformAnimation(animation);\n    var res = baseOnFrame(animation, timestamp);\n    transformAnimation(animation);\n    return res;\n  };\n\n  var tab = ['H', 'S', 'V', 'A'];\n\n  var colorOnStart = function colorOnStart(animation, value, timestamp, previousAnimation) {\n    var HSVAValue;\n    var HSVACurrent;\n    var HSVAToValue;\n    var res = [];\n\n    if ((0, _Colors.isColor)(value)) {\n      HSVACurrent = (0, _Colors.convertToHSVA)(animation.current);\n      HSVAValue = (0, _Colors.convertToHSVA)(value);\n\n      if (animation.toValue) {\n        HSVAToValue = (0, _Colors.convertToHSVA)(animation.toValue);\n      }\n    }\n\n    tab.forEach(function (i, index) {\n      animation[i] = (0, _extends2.default)({}, animationCopy);\n      animation[i].current = HSVACurrent[index];\n      animation[i].toValue = HSVAToValue ? HSVAToValue[index] : undefined;\n      animation[i].onStart(animation[i], HSVAValue[index], timestamp, previousAnimation ? previousAnimation[i] : undefined);\n      res.push(animation[i].current);\n    });\n    animation.current = (0, _Colors.toRGBA)(res);\n  };\n\n  var colorOnFrame = function colorOnFrame(animation, timestamp) {\n    var HSVACurrent = (0, _Colors.convertToHSVA)(animation.current);\n    var res = [];\n    var finished = true;\n    tab.forEach(function (i, index) {\n      animation[i].current = HSVACurrent[index];\n      finished &= animation[i].onFrame(animation[i], timestamp);\n      res.push(animation[i].current);\n    });\n    animation.current = (0, _Colors.toRGBA)(res);\n    return finished;\n  };\n\n  animation.onStart = function (animation, value, timestamp, previousAnimation) {\n    if ((0, _Colors.isColor)(value)) {\n      colorOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = colorOnFrame;\n      return;\n    } else if (typeof value === 'string') {\n      prefNumberSuffOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = prefNumberSuffOnFrame;\n      return;\n    }\n\n    baseOnStart(animation, value, timestamp, previousAnimation);\n  };\n}\n\nfunction defineAnimation(starting, factory) {\n  'worklet';\n\n  if (IN_STYLE_UPDATER) {\n    return starting;\n  }\n\n  var create = function create() {\n    'worklet';\n\n    var animation = factory();\n    decorateAnimation(animation);\n    return animation;\n  };\n\n  if (_WORKLET || !_NativeReanimated.default.native) {\n    return create();\n  }\n\n  return create;\n}\n\nfunction cancelAnimation(sharedValue) {\n  'worklet';\n\n  sharedValue.value = sharedValue.value;\n}\n\nfunction withTiming(toValue, userConfig, callback) {\n  'worklet';\n\n  return defineAnimation(toValue, function () {\n    'worklet';\n\n    var config = {\n      duration: 300,\n      easing: _Easing.Easing.inOut(_Easing.Easing.quad)\n    };\n\n    if (userConfig) {\n      Object.keys(userConfig).forEach(function (key) {\n        return config[key] = userConfig[key];\n      });\n    }\n\n    function timing(animation, now) {\n      var toValue = animation.toValue,\n          progress = animation.progress,\n          startTime = animation.startTime,\n          current = animation.current;\n      var runtime = now - startTime;\n\n      if (runtime >= config.duration) {\n        animation.startTime = 0;\n        animation.current = toValue;\n        return true;\n      }\n\n      var newProgress = config.easing(runtime / config.duration);\n      var dist = (toValue - current) * (newProgress - progress) / (1 - progress);\n      animation.current += dist;\n      animation.progress = newProgress;\n      return false;\n    }\n\n    function onStart(animation, value, now, previousAnimation) {\n      if (previousAnimation && previousAnimation.type === 'timing' && previousAnimation.toValue === toValue && previousAnimation.startTime) {\n        animation.startTime = previousAnimation.startTime;\n        animation.progress = previousAnimation.progress;\n      } else {\n        animation.startTime = now;\n        animation.progress = 0;\n      }\n\n      animation.current = value;\n    }\n\n    return {\n      type: 'timing',\n      onFrame: timing,\n      onStart: onStart,\n      progress: 0,\n      toValue: toValue,\n      current: toValue,\n      callback: callback\n    };\n  });\n}\n\nfunction withSpring(toValue, userConfig, callback) {\n  'worklet';\n\n  return defineAnimation(toValue, function () {\n    'worklet';\n\n    var config = {\n      damping: 10,\n      mass: 1,\n      stiffness: 100,\n      overshootClamping: false,\n      restDisplacementThreshold: 0.01,\n      restSpeedThreshold: 2\n    };\n\n    if (userConfig) {\n      Object.keys(userConfig).forEach(function (key) {\n        return config[key] = userConfig[key];\n      });\n    }\n\n    function spring(animation, now) {\n      var toValue = animation.toValue,\n          lastTimestamp = animation.lastTimestamp,\n          current = animation.current,\n          velocity = animation.velocity;\n      var deltaTime = Math.min(now - lastTimestamp, 64);\n      animation.lastTimestamp = now;\n      var c = config.damping;\n      var m = config.mass;\n      var k = config.stiffness;\n      var v0 = -velocity;\n      var x0 = toValue - current;\n      var zeta = c / (2 * Math.sqrt(k * m));\n      var omega0 = Math.sqrt(k / m);\n      var omega1 = omega0 * Math.sqrt(1 - Math.pow(zeta, 2));\n      var t = deltaTime / 1000;\n      var sin1 = Math.sin(omega1 * t);\n      var cos1 = Math.cos(omega1 * t);\n      var underDampedEnvelope = Math.exp(-zeta * omega0 * t);\n      var underDampedFrag1 = underDampedEnvelope * (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);\n      var underDampedPosition = toValue - underDampedFrag1;\n      var underDampedVelocity = zeta * omega0 * underDampedFrag1 - underDampedEnvelope * (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);\n      var criticallyDampedEnvelope = Math.exp(-omega0 * t);\n      var criticallyDampedPosition = toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);\n      var criticallyDampedVelocity = criticallyDampedEnvelope * (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);\n\n      var isOvershooting = function isOvershooting() {\n        if (config.overshootClamping && config.stiffness !== 0) {\n          return current < toValue ? animation.current > toValue : animation.current < toValue;\n        } else {\n          return false;\n        }\n      };\n\n      var isVelocity = Math.abs(velocity) < config.restSpeedThreshold;\n      var isDisplacement = config.stiffness === 0 || Math.abs(toValue - current) < config.restDisplacementThreshold;\n\n      if (zeta < 1) {\n        animation.current = underDampedPosition;\n        animation.velocity = underDampedVelocity;\n      } else {\n        animation.current = criticallyDampedPosition;\n        animation.velocity = criticallyDampedVelocity;\n      }\n\n      if (isOvershooting() || isVelocity && isDisplacement) {\n        if (config.stiffness !== 0) {\n          animation.velocity = 0;\n          animation.current = toValue;\n        }\n\n        return true;\n      }\n    }\n\n    function onStart(animation, value, now, previousAnimation) {\n      animation.current = value;\n\n      if (previousAnimation) {\n        animation.velocity = previousAnimation.velocity || animation.velocity || 0;\n        animation.lastTimestamp = previousAnimation.lastTimestamp || now;\n      } else {\n        animation.lastTimestamp = now;\n      }\n    }\n\n    return {\n      onFrame: spring,\n      onStart: onStart,\n      toValue: toValue,\n      velocity: config.velocity || 0,\n      current: toValue,\n      callback: callback\n    };\n  });\n}\n\nfunction withDecay(userConfig, callback) {\n  'worklet';\n\n  return defineAnimation(0, function () {\n    'worklet';\n\n    var config = {\n      deceleration: 0.998\n    };\n\n    if (userConfig) {\n      Object.keys(userConfig).forEach(function (key) {\n        return config[key] = userConfig[key];\n      });\n    }\n\n    var VELOCITY_EPS = 5;\n\n    function decay(animation, now) {\n      var lastTimestamp = animation.lastTimestamp,\n          initialVelocity = animation.initialVelocity,\n          current = animation.current,\n          velocity = animation.velocity;\n      var deltaTime = Math.min(now - lastTimestamp, 64);\n      animation.lastTimestamp = now;\n      var kv = Math.pow(config.deceleration, deltaTime);\n      var kx = config.deceleration * (1 - kv) / (1 - config.deceleration);\n      var v0 = velocity / 1000;\n      var v = v0 * kv * 1000;\n      var x = current + v0 * kx;\n      animation.current = x;\n      animation.velocity = v;\n      var toValueIsReached = null;\n\n      if (Array.isArray(config.clamp)) {\n        if (initialVelocity < 0 && animation.current <= config.clamp[0]) {\n          toValueIsReached = config.clamp[0];\n        } else if (initialVelocity > 0 && animation.current >= config.clamp[1]) {\n          toValueIsReached = config.clamp[1];\n        }\n      }\n\n      if (Math.abs(v) < VELOCITY_EPS || toValueIsReached !== null) {\n        if (toValueIsReached !== null) {\n          animation.current = toValueIsReached;\n        }\n\n        return true;\n      }\n    }\n\n    function onStart(animation, value, now) {\n      animation.current = value;\n      animation.lastTimestamp = now;\n      animation.initialVelocity = config.velocity;\n    }\n\n    return {\n      onFrame: decay,\n      onStart: onStart,\n      velocity: config.velocity || 0,\n      callback: callback\n    };\n  });\n}\n\nfunction withDelay(delayMs, _nextAnimation) {\n  'worklet';\n\n  return defineAnimation(_nextAnimation, function () {\n    'worklet';\n\n    var nextAnimation = typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;\n\n    function delay(animation, now) {\n      var startTime = animation.startTime,\n          started = animation.started,\n          previousAnimation = animation.previousAnimation;\n\n      if (now - startTime > delayMs) {\n        if (!started) {\n          nextAnimation.onStart(nextAnimation, animation.current, now, previousAnimation);\n          animation.previousAnimation = null;\n          animation.started = true;\n        }\n\n        var finished = nextAnimation.onFrame(nextAnimation, now);\n        animation.current = nextAnimation.current;\n        return finished;\n      } else if (previousAnimation) {\n        var _finished = previousAnimation.onFrame(previousAnimation, now);\n\n        animation.current = previousAnimation.current;\n\n        if (_finished) {\n          animation.previousAnimation = null;\n        }\n      }\n\n      return false;\n    }\n\n    function onStart(animation, value, now, previousAnimation) {\n      animation.startTime = now;\n      animation.started = false;\n      animation.current = value;\n      animation.previousAnimation = previousAnimation;\n    }\n\n    var callback = function callback(finished) {\n      if (nextAnimation.callback) {\n        nextAnimation.callback(finished);\n      }\n    };\n\n    return {\n      isHigherOrder: true,\n      onFrame: delay,\n      onStart: onStart,\n      current: nextAnimation.current,\n      callback: callback\n    };\n  });\n}\n\nfunction withSequence() {\n  'worklet';\n\n  for (var _len = arguments.length, _animations = new Array(_len), _key = 0; _key < _len; _key++) {\n    _animations[_key] = arguments[_key];\n  }\n\n  return defineAnimation(_animations[0], function () {\n    'worklet';\n\n    var animations = _animations.map(function (a) {\n      var result = typeof a === 'function' ? a() : a;\n      result.finished = false;\n      return result;\n    });\n\n    var firstAnimation = animations[0];\n\n    var callback = function callback(finished) {\n      if (finished) {\n        return;\n      }\n\n      animations.forEach(function (animation) {\n        if (typeof animation.callback === 'function' && !animation.finished) {\n          animation.callback(finished);\n        }\n      });\n    };\n\n    function sequence(animation, now) {\n      var currentAnim = animations[animation.animationIndex];\n      var finished = currentAnim.onFrame(currentAnim, now);\n      animation.current = currentAnim.current;\n\n      if (finished) {\n        if (currentAnim.callback) {\n          currentAnim.callback(true);\n        }\n\n        currentAnim.finished = true;\n        animation.animationIndex += 1;\n\n        if (animation.animationIndex < animations.length) {\n          var nextAnim = animations[animation.animationIndex];\n          nextAnim.onStart(nextAnim, currentAnim.current, now, currentAnim);\n          return false;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n\n    function onStart(animation, value, now, previousAnimation) {\n      if (animations.length === 1) {\n        throw Error('withSequence() animation require more than one animation as argument');\n      }\n\n      animation.animationIndex = 0;\n\n      if (previousAnimation === undefined) {\n        previousAnimation = animations[animations.length - 1];\n      }\n\n      firstAnimation.onStart(firstAnimation, value, now, previousAnimation);\n    }\n\n    return {\n      isHigherOrder: true,\n      onFrame: sequence,\n      onStart: onStart,\n      animationIndex: 0,\n      current: firstAnimation.current,\n      callback: callback\n    };\n  });\n}\n\nfunction withRepeat(_nextAnimation) {\n  'worklet';\n\n  var numberOfReps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  var reverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var callback = arguments.length > 3 ? arguments[3] : undefined;\n  return defineAnimation(_nextAnimation, function () {\n    'worklet';\n\n    var nextAnimation = typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;\n\n    function repeat(animation, now) {\n      var finished = nextAnimation.onFrame(nextAnimation, now);\n      animation.current = nextAnimation.current;\n\n      if (finished) {\n        animation.reps += 1;\n\n        if (nextAnimation.callback) {\n          nextAnimation.callback(true, animation.current);\n        }\n\n        if (numberOfReps > 0 && animation.reps >= numberOfReps) {\n          return true;\n        }\n\n        var startValue = reverse ? nextAnimation.current : animation.startValue;\n\n        if (reverse) {\n          nextAnimation.toValue = animation.startValue;\n          animation.startValue = startValue;\n        }\n\n        nextAnimation.onStart(nextAnimation, startValue, now, nextAnimation.previousAnimation);\n        return false;\n      }\n\n      return false;\n    }\n\n    var repCallback = function repCallback(finished) {\n      if (callback) {\n        callback(finished);\n      }\n\n      if (!finished && nextAnimation.callback) {\n        nextAnimation.callback(false);\n      }\n    };\n\n    function onStart(animation, value, now, previousAnimation) {\n      animation.startValue = value;\n      animation.reps = 0;\n      nextAnimation.onStart(nextAnimation, value, now, previousAnimation);\n    }\n\n    return {\n      isHigherOrder: true,\n      onFrame: repeat,\n      onStart: onStart,\n      reps: 0,\n      current: nextAnimation.current,\n      callback: repCallback\n    };\n  });\n}\n\nfunction delay(delayMs, _nextAnimation) {\n  'worklet';\n\n  console.warn('Method `delay` is deprecated. Please use `withDelay` instead');\n  return withDelay(delayMs, _nextAnimation);\n}\n\nfunction repeat(_nextAnimation) {\n  'worklet';\n\n  var numberOfReps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  var reverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var callback = arguments.length > 3 ? arguments[3] : undefined;\n  console.warn('Method `repeat` is deprecated. Please use `withRepeat` instead');\n  return withRepeat(_nextAnimation, numberOfReps, reverse, callback);\n}\n\nfunction loop(nextAnimation) {\n  'worklet';\n\n  var numberOfLoops = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  console.warn('Method `loop` is deprecated. Please use `withRepeat` instead');\n  return repeat(nextAnimation, Math.round(numberOfLoops * 2), true);\n}\n\nfunction sequence() {\n  'worklet';\n\n  console.warn('Method `sequence` is deprecated. Please use `withSequence` instead');\n  return withSequence.apply(void 0, arguments);\n}","map":{"version":3,"sources":["/Users/user/projects/HarlemHaberdashery/node_modules/react-native-reanimated/src/reanimated2/animations.js"],"names":["IN_STYLE_UPDATER","initialUpdaterRun","updater","result","transform","value","handler","undefined","match","prefix","suffix","number","__prefix","__suffix","parseFloat","transformAnimation","animation","toValue","current","startValue","decorateAnimation","isHigherOrder","baseOnStart","onStart","baseOnFrame","onFrame","animationCopy","callback","prefNumberSuffOnStart","timestamp","previousAnimation","val","prefNumberSuffOnFrame","res","tab","colorOnStart","HSVAValue","HSVACurrent","HSVAToValue","forEach","i","index","push","colorOnFrame","finished","defineAnimation","starting","factory","create","_WORKLET","NativeReanimated","native","cancelAnimation","sharedValue","withTiming","userConfig","config","duration","easing","Easing","inOut","quad","Object","keys","key","timing","now","progress","startTime","runtime","newProgress","dist","type","withSpring","damping","mass","stiffness","overshootClamping","restDisplacementThreshold","restSpeedThreshold","spring","lastTimestamp","velocity","deltaTime","Math","min","c","m","k","v0","x0","zeta","sqrt","omega0","omega1","t","sin1","sin","cos1","cos","underDampedEnvelope","exp","underDampedFrag1","underDampedPosition","underDampedVelocity","criticallyDampedEnvelope","criticallyDampedPosition","criticallyDampedVelocity","isOvershooting","isVelocity","abs","isDisplacement","withDecay","deceleration","VELOCITY_EPS","decay","initialVelocity","kv","pow","kx","v","x","toValueIsReached","Array","isArray","clamp","withDelay","delayMs","_nextAnimation","nextAnimation","delay","started","withSequence","_animations","animations","map","a","firstAnimation","sequence","currentAnim","animationIndex","length","nextAnim","Error","withRepeat","numberOfReps","reverse","repeat","reps","repCallback","console","warn","loop","numberOfLoops","round"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AACA;;AACA;;AACA;;AAEA,IAAIA,gBAAgB,GAAG,KAAvB;;AAEO,SAASC,iBAAT,CAA2BC,OAA3B,EAAoC;AACzCF,EAAAA,gBAAgB,GAAG,IAAnB;AACA,MAAMG,MAAM,GAAGD,OAAO,EAAtB;AACAF,EAAAA,gBAAgB,GAAG,KAAnB;AACA,SAAOG,MAAP;AACD;;AAEM,SAASC,SAAT,CAAmBC,KAAnB,EAA0BC,OAA1B,EAAmC;AACxC;;AACA,MAAID,KAAK,KAAKE,SAAd,EAAyB;AACvB,WAAOA,SAAP;AACD;;AAED,MAAI,OAAOF,KAAP,KAAiB,QAArB,EAA+B;AAG7B,QAAMG,KAAK,GAAGH,KAAK,CAACG,KAAN,CAAY,sCAAZ,CAAd;AACA,QAAMC,MAAM,GAAGD,KAAK,CAAC,CAAD,CAApB;AACA,QAAME,MAAM,GAAGF,KAAK,CAAC,CAAD,CAApB;AACA,QAAMG,MAAM,GAAGH,KAAK,CAAC,CAAD,CAApB;AACAF,IAAAA,OAAO,CAACM,QAAR,GAAmBH,MAAnB;AACAH,IAAAA,OAAO,CAACO,QAAR,GAAmBH,MAAnB;AACA,WAAOI,UAAU,CAACH,MAAD,CAAjB;AACD;;AAGD,MAAIL,OAAO,CAACM,QAAR,KAAqBL,SAAzB,EAAoC;AAClC,WAAOF,KAAP;AACD;;AAED,SAAOC,OAAO,CAACM,QAAR,GAAmBP,KAAnB,GAA2BC,OAAO,CAACO,QAA1C;AACD;;AAEM,SAASE,kBAAT,CAA4BC,SAA5B,EAAuC;AAC5C;;AACA,MAAI,CAACA,SAAL,EAAgB;AACd;AACD;;AACDA,EAAAA,SAAS,CAACC,OAAV,GAAoBb,SAAS,CAACY,SAAS,CAACC,OAAX,EAAoBD,SAApB,CAA7B;AACAA,EAAAA,SAAS,CAACE,OAAV,GAAoBd,SAAS,CAACY,SAAS,CAACE,OAAX,EAAoBF,SAApB,CAA7B;AACAA,EAAAA,SAAS,CAACG,UAAV,GAAuBf,SAAS,CAACY,SAAS,CAACG,UAAX,EAAuBH,SAAvB,CAAhC;AACD;;AAEM,SAASI,iBAAT,CAA2BJ,SAA3B,EAAsC;AAC3C;;AACA,MAAIA,SAAS,CAACK,aAAd,EAA6B;AAC3B;AACD;;AACD,MAAMC,WAAW,GAAGN,SAAS,CAACO,OAA9B;AACA,MAAMC,WAAW,GAAGR,SAAS,CAACS,OAA9B;AACA,MAAMC,aAAa,GAAG,uBAAc,EAAd,EAAkBV,SAAlB,CAAtB;AACA,SAAOU,aAAa,CAACC,QAArB;;AAEA,MAAMC,qBAAqB,GAAG,SAAxBA,qBAAwB,CAC5BZ,SAD4B,EAE5BX,KAF4B,EAG5BwB,SAH4B,EAI5BC,iBAJ4B,EAKzB;AACH,QAAMC,GAAG,GAAG3B,SAAS,CAACC,KAAD,EAAQW,SAAR,CAArB;AACAD,IAAAA,kBAAkB,CAACC,SAAD,CAAlB;AACA,QAAIc,iBAAiB,KAAKd,SAA1B,EAAqCD,kBAAkB,CAACe,iBAAD,CAAlB;AAErCR,IAAAA,WAAW,CAACN,SAAD,EAAYe,GAAZ,EAAiBF,SAAjB,EAA4BC,iBAA5B,CAAX;AAEAf,IAAAA,kBAAkB,CAACC,SAAD,CAAlB;AACA,QAAIc,iBAAiB,KAAKd,SAA1B,EAAqCD,kBAAkB,CAACe,iBAAD,CAAlB;AACtC,GAdD;;AAeA,MAAME,qBAAqB,GAAG,SAAxBA,qBAAwB,CAAChB,SAAD,EAAYa,SAAZ,EAA0B;AACtDd,IAAAA,kBAAkB,CAACC,SAAD,CAAlB;AAEA,QAAMiB,GAAG,GAAGT,WAAW,CAACR,SAAD,EAAYa,SAAZ,CAAvB;AAEAd,IAAAA,kBAAkB,CAACC,SAAD,CAAlB;AACA,WAAOiB,GAAP;AACD,GAPD;;AASA,MAAMC,GAAG,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,CAAZ;;AACA,MAAMC,YAAY,GAAG,SAAfA,YAAe,CAACnB,SAAD,EAAYX,KAAZ,EAAmBwB,SAAnB,EAA8BC,iBAA9B,EAAoD;AACvE,QAAIM,SAAJ;AACA,QAAIC,WAAJ;AACA,QAAIC,WAAJ;AACA,QAAML,GAAG,GAAG,EAAZ;;AACA,QAAI,qBAAQ5B,KAAR,CAAJ,EAAoB;AAClBgC,MAAAA,WAAW,GAAG,2BAAcrB,SAAS,CAACE,OAAxB,CAAd;AACAkB,MAAAA,SAAS,GAAG,2BAAc/B,KAAd,CAAZ;;AACA,UAAIW,SAAS,CAACC,OAAd,EAAuB;AACrBqB,QAAAA,WAAW,GAAG,2BAActB,SAAS,CAACC,OAAxB,CAAd;AACD;AACF;;AACDiB,IAAAA,GAAG,CAACK,OAAJ,CAAY,UAACC,CAAD,EAAIC,KAAJ,EAAc;AACxBzB,MAAAA,SAAS,CAACwB,CAAD,CAAT,GAAe,uBAAc,EAAd,EAAkBd,aAAlB,CAAf;AACAV,MAAAA,SAAS,CAACwB,CAAD,CAAT,CAAatB,OAAb,GAAuBmB,WAAW,CAACI,KAAD,CAAlC;AACAzB,MAAAA,SAAS,CAACwB,CAAD,CAAT,CAAavB,OAAb,GAAuBqB,WAAW,GAAGA,WAAW,CAACG,KAAD,CAAd,GAAwBlC,SAA1D;AACAS,MAAAA,SAAS,CAACwB,CAAD,CAAT,CAAajB,OAAb,CACEP,SAAS,CAACwB,CAAD,CADX,EAEEJ,SAAS,CAACK,KAAD,CAFX,EAGEZ,SAHF,EAIEC,iBAAiB,GAAGA,iBAAiB,CAACU,CAAD,CAApB,GAA0BjC,SAJ7C;AAMA0B,MAAAA,GAAG,CAACS,IAAJ,CAAS1B,SAAS,CAACwB,CAAD,CAAT,CAAatB,OAAtB;AACD,KAXD;AAaAF,IAAAA,SAAS,CAACE,OAAV,GAAoB,oBAAOe,GAAP,CAApB;AACD,GA1BD;;AA4BA,MAAMU,YAAY,GAAG,SAAfA,YAAe,CAAC3B,SAAD,EAAYa,SAAZ,EAA0B;AAC7C,QAAMQ,WAAW,GAAG,2BAAcrB,SAAS,CAACE,OAAxB,CAApB;AACA,QAAMe,GAAG,GAAG,EAAZ;AACA,QAAIW,QAAQ,GAAG,IAAf;AACAV,IAAAA,GAAG,CAACK,OAAJ,CAAY,UAACC,CAAD,EAAIC,KAAJ,EAAc;AACxBzB,MAAAA,SAAS,CAACwB,CAAD,CAAT,CAAatB,OAAb,GAAuBmB,WAAW,CAACI,KAAD,CAAlC;AACAG,MAAAA,QAAQ,IAAI5B,SAAS,CAACwB,CAAD,CAAT,CAAaf,OAAb,CAAqBT,SAAS,CAACwB,CAAD,CAA9B,EAAmCX,SAAnC,CAAZ;AACAI,MAAAA,GAAG,CAACS,IAAJ,CAAS1B,SAAS,CAACwB,CAAD,CAAT,CAAatB,OAAtB;AACD,KAJD;AAMAF,IAAAA,SAAS,CAACE,OAAV,GAAoB,oBAAOe,GAAP,CAApB;AACA,WAAOW,QAAP;AACD,GAZD;;AAcA5B,EAAAA,SAAS,CAACO,OAAV,GAAoB,UAACP,SAAD,EAAYX,KAAZ,EAAmBwB,SAAnB,EAA8BC,iBAA9B,EAAoD;AACtE,QAAI,qBAAQzB,KAAR,CAAJ,EAAoB;AAClB8B,MAAAA,YAAY,CAACnB,SAAD,EAAYX,KAAZ,EAAmBwB,SAAnB,EAA8BC,iBAA9B,CAAZ;AACAd,MAAAA,SAAS,CAACS,OAAV,GAAoBkB,YAApB;AACA;AACD,KAJD,MAIO,IAAI,OAAOtC,KAAP,KAAiB,QAArB,EAA+B;AACpCuB,MAAAA,qBAAqB,CAACZ,SAAD,EAAYX,KAAZ,EAAmBwB,SAAnB,EAA8BC,iBAA9B,CAArB;AACAd,MAAAA,SAAS,CAACS,OAAV,GAAoBO,qBAApB;AACA;AACD;;AACDV,IAAAA,WAAW,CAACN,SAAD,EAAYX,KAAZ,EAAmBwB,SAAnB,EAA8BC,iBAA9B,CAAX;AACD,GAXD;AAYD;;AAEM,SAASe,eAAT,CAAyBC,QAAzB,EAAmCC,OAAnC,EAA4C;AACjD;;AACA,MAAI/C,gBAAJ,EAAsB;AACpB,WAAO8C,QAAP;AACD;;AACD,MAAME,MAAM,GAAG,SAATA,MAAS,GAAM;AACnB;;AACA,QAAMhC,SAAS,GAAG+B,OAAO,EAAzB;AACA3B,IAAAA,iBAAiB,CAACJ,SAAD,CAAjB;AACA,WAAOA,SAAP;AACD,GALD;;AAOA,MAAIiC,QAAQ,IAAI,CAACC,0BAAiBC,MAAlC,EAA0C;AACxC,WAAOH,MAAM,EAAb;AACD;;AACD,SAAOA,MAAP;AACD;;AAEM,SAASI,eAAT,CAAyBC,WAAzB,EAAsC;AAC3C;;AAEAA,EAAAA,WAAW,CAAChD,KAAZ,GAAoBgD,WAAW,CAAChD,KAAhC;AACD;;AAEM,SAASiD,UAAT,CAAoBrC,OAApB,EAA6BsC,UAA7B,EAAyC5B,QAAzC,EAAmD;AACxD;;AAEA,SAAOkB,eAAe,CAAC5B,OAAD,EAAU,YAAM;AACpC;;AACA,QAAMuC,MAAM,GAAG;AACbC,MAAAA,QAAQ,EAAE,GADG;AAEbC,MAAAA,MAAM,EAAEC,eAAOC,KAAP,CAAaD,eAAOE,IAApB;AAFK,KAAf;;AAIA,QAAIN,UAAJ,EAAgB;AACdO,MAAAA,MAAM,CAACC,IAAP,CAAYR,UAAZ,EAAwBhB,OAAxB,CAAgC,UAACyB,GAAD;AAAA,eAAUR,MAAM,CAACQ,GAAD,CAAN,GAAcT,UAAU,CAACS,GAAD,CAAlC;AAAA,OAAhC;AACD;;AAED,aAASC,MAAT,CAAgBjD,SAAhB,EAA2BkD,GAA3B,EAAgC;AAAA,UACtBjD,OADsB,GACoBD,SADpB,CACtBC,OADsB;AAAA,UACbkD,QADa,GACoBnD,SADpB,CACbmD,QADa;AAAA,UACHC,SADG,GACoBpD,SADpB,CACHoD,SADG;AAAA,UACQlD,OADR,GACoBF,SADpB,CACQE,OADR;AAG9B,UAAMmD,OAAO,GAAGH,GAAG,GAAGE,SAAtB;;AAEA,UAAIC,OAAO,IAAIb,MAAM,CAACC,QAAtB,EAAgC;AAE9BzC,QAAAA,SAAS,CAACoD,SAAV,GAAsB,CAAtB;AACApD,QAAAA,SAAS,CAACE,OAAV,GAAoBD,OAApB;AACA,eAAO,IAAP;AACD;;AAED,UAAMqD,WAAW,GAAGd,MAAM,CAACE,MAAP,CAAcW,OAAO,GAAGb,MAAM,CAACC,QAA/B,CAApB;AAEA,UAAMc,IAAI,GACP,CAACtD,OAAO,GAAGC,OAAX,KAAuBoD,WAAW,GAAGH,QAArC,CAAD,IAAoD,IAAIA,QAAxD,CADF;AAEAnD,MAAAA,SAAS,CAACE,OAAV,IAAqBqD,IAArB;AACAvD,MAAAA,SAAS,CAACmD,QAAV,GAAqBG,WAArB;AACA,aAAO,KAAP;AACD;;AAED,aAAS/C,OAAT,CAAiBP,SAAjB,EAA4BX,KAA5B,EAAmC6D,GAAnC,EAAwCpC,iBAAxC,EAA2D;AACzD,UACEA,iBAAiB,IACjBA,iBAAiB,CAAC0C,IAAlB,KAA2B,QAD3B,IAEA1C,iBAAiB,CAACb,OAAlB,KAA8BA,OAF9B,IAGAa,iBAAiB,CAACsC,SAJpB,EAKE;AAIApD,QAAAA,SAAS,CAACoD,SAAV,GAAsBtC,iBAAiB,CAACsC,SAAxC;AACApD,QAAAA,SAAS,CAACmD,QAAV,GAAqBrC,iBAAiB,CAACqC,QAAvC;AACD,OAXD,MAWO;AACLnD,QAAAA,SAAS,CAACoD,SAAV,GAAsBF,GAAtB;AACAlD,QAAAA,SAAS,CAACmD,QAAV,GAAqB,CAArB;AACD;;AACDnD,MAAAA,SAAS,CAACE,OAAV,GAAoBb,KAApB;AACD;;AAED,WAAO;AACLmE,MAAAA,IAAI,EAAE,QADD;AAEL/C,MAAAA,OAAO,EAAEwC,MAFJ;AAGL1C,MAAAA,OAAO,EAAPA,OAHK;AAIL4C,MAAAA,QAAQ,EAAE,CAJL;AAKLlD,MAAAA,OAAO,EAAPA,OALK;AAMLC,MAAAA,OAAO,EAAED,OANJ;AAOLU,MAAAA,QAAQ,EAARA;AAPK,KAAP;AASD,GA3DqB,CAAtB;AA4DD;;AAEM,SAAS8C,UAAT,CAAoBxD,OAApB,EAA6BsC,UAA7B,EAAyC5B,QAAzC,EAAmD;AACxD;;AAEA,SAAOkB,eAAe,CAAC5B,OAAD,EAAU,YAAM;AACpC;;AAKA,QAAMuC,MAAM,GAAG;AACbkB,MAAAA,OAAO,EAAE,EADI;AAEbC,MAAAA,IAAI,EAAE,CAFO;AAGbC,MAAAA,SAAS,EAAE,GAHE;AAIbC,MAAAA,iBAAiB,EAAE,KAJN;AAKbC,MAAAA,yBAAyB,EAAE,IALd;AAMbC,MAAAA,kBAAkB,EAAE;AANP,KAAf;;AAQA,QAAIxB,UAAJ,EAAgB;AACdO,MAAAA,MAAM,CAACC,IAAP,CAAYR,UAAZ,EAAwBhB,OAAxB,CAAgC,UAACyB,GAAD;AAAA,eAAUR,MAAM,CAACQ,GAAD,CAAN,GAAcT,UAAU,CAACS,GAAD,CAAlC;AAAA,OAAhC;AACD;;AAED,aAASgB,MAAT,CAAgBhE,SAAhB,EAA2BkD,GAA3B,EAAgC;AAAA,UACtBjD,OADsB,GACwBD,SADxB,CACtBC,OADsB;AAAA,UACbgE,aADa,GACwBjE,SADxB,CACbiE,aADa;AAAA,UACE/D,OADF,GACwBF,SADxB,CACEE,OADF;AAAA,UACWgE,QADX,GACwBlE,SADxB,CACWkE,QADX;AAG9B,UAAMC,SAAS,GAAGC,IAAI,CAACC,GAAL,CAASnB,GAAG,GAAGe,aAAf,EAA8B,EAA9B,CAAlB;AACAjE,MAAAA,SAAS,CAACiE,aAAV,GAA0Bf,GAA1B;AAEA,UAAMoB,CAAC,GAAG9B,MAAM,CAACkB,OAAjB;AACA,UAAMa,CAAC,GAAG/B,MAAM,CAACmB,IAAjB;AACA,UAAMa,CAAC,GAAGhC,MAAM,CAACoB,SAAjB;AAEA,UAAMa,EAAE,GAAG,CAACP,QAAZ;AACA,UAAMQ,EAAE,GAAGzE,OAAO,GAAGC,OAArB;AAEA,UAAMyE,IAAI,GAAGL,CAAC,IAAI,IAAIF,IAAI,CAACQ,IAAL,CAAUJ,CAAC,GAAGD,CAAd,CAAR,CAAd;AACA,UAAMM,MAAM,GAAGT,IAAI,CAACQ,IAAL,CAAUJ,CAAC,GAAGD,CAAd,CAAf;AACA,UAAMO,MAAM,GAAGD,MAAM,GAAGT,IAAI,CAACQ,IAAL,CAAU,aAAID,IAAJ,EAAY,CAAZ,CAAV,CAAxB;AAEA,UAAMI,CAAC,GAAGZ,SAAS,GAAG,IAAtB;AAEA,UAAMa,IAAI,GAAGZ,IAAI,CAACa,GAAL,CAASH,MAAM,GAAGC,CAAlB,CAAb;AACA,UAAMG,IAAI,GAAGd,IAAI,CAACe,GAAL,CAASL,MAAM,GAAGC,CAAlB,CAAb;AAGA,UAAMK,mBAAmB,GAAGhB,IAAI,CAACiB,GAAL,CAAS,CAACV,IAAD,GAAQE,MAAR,GAAiBE,CAA1B,CAA5B;AACA,UAAMO,gBAAgB,GACpBF,mBAAmB,IAClBJ,IAAI,IAAI,CAACP,EAAE,GAAGE,IAAI,GAAGE,MAAP,GAAgBH,EAAtB,IAA4BI,MAAhC,CAAJ,GAA8CJ,EAAE,GAAGQ,IADjC,CADrB;AAIA,UAAMK,mBAAmB,GAAGtF,OAAO,GAAGqF,gBAAtC;AAEA,UAAME,mBAAmB,GACvBb,IAAI,GAAGE,MAAP,GAAgBS,gBAAhB,GACAF,mBAAmB,IAChBF,IAAI,IAAIT,EAAE,GAAGE,IAAI,GAAGE,MAAP,GAAgBH,EAAzB,CAAJ,GAAmCI,MAAM,GAAGJ,EAAT,GAAcM,IADjC,CAFrB;AAMA,UAAMS,wBAAwB,GAAGrB,IAAI,CAACiB,GAAL,CAAS,CAACR,MAAD,GAAUE,CAAnB,CAAjC;AACA,UAAMW,wBAAwB,GAC5BzF,OAAO,GAAGwF,wBAAwB,IAAIf,EAAE,GAAG,CAACD,EAAE,GAAGI,MAAM,GAAGH,EAAf,IAAqBK,CAA9B,CADpC;AAGA,UAAMY,wBAAwB,GAC5BF,wBAAwB,IACvBhB,EAAE,IAAIM,CAAC,GAAGF,MAAJ,GAAa,CAAjB,CAAF,GAAwBE,CAAC,GAAGL,EAAJ,GAASG,MAAT,GAAkBA,MADnB,CAD1B;;AAIA,UAAMe,cAAc,GAAG,SAAjBA,cAAiB,GAAM;AAC3B,YAAIpD,MAAM,CAACqB,iBAAP,IAA4BrB,MAAM,CAACoB,SAAP,KAAqB,CAArD,EAAwD;AACtD,iBAAO1D,OAAO,GAAGD,OAAV,GACHD,SAAS,CAACE,OAAV,GAAoBD,OADjB,GAEHD,SAAS,CAACE,OAAV,GAAoBD,OAFxB;AAGD,SAJD,MAIO;AACL,iBAAO,KAAP;AACD;AACF,OARD;;AAUA,UAAM4F,UAAU,GAAGzB,IAAI,CAAC0B,GAAL,CAAS5B,QAAT,IAAqB1B,MAAM,CAACuB,kBAA/C;AACA,UAAMgC,cAAc,GAClBvD,MAAM,CAACoB,SAAP,KAAqB,CAArB,IACAQ,IAAI,CAAC0B,GAAL,CAAS7F,OAAO,GAAGC,OAAnB,IAA8BsC,MAAM,CAACsB,yBAFvC;;AAIA,UAAIa,IAAI,GAAG,CAAX,EAAc;AACZ3E,QAAAA,SAAS,CAACE,OAAV,GAAoBqF,mBAApB;AACAvF,QAAAA,SAAS,CAACkE,QAAV,GAAqBsB,mBAArB;AACD,OAHD,MAGO;AACLxF,QAAAA,SAAS,CAACE,OAAV,GAAoBwF,wBAApB;AACA1F,QAAAA,SAAS,CAACkE,QAAV,GAAqByB,wBAArB;AACD;;AAED,UAAIC,cAAc,MAAOC,UAAU,IAAIE,cAAvC,EAAwD;AACtD,YAAIvD,MAAM,CAACoB,SAAP,KAAqB,CAAzB,EAA4B;AAC1B5D,UAAAA,SAAS,CAACkE,QAAV,GAAqB,CAArB;AACAlE,UAAAA,SAAS,CAACE,OAAV,GAAoBD,OAApB;AACD;;AACD,eAAO,IAAP;AACD;AACF;;AAED,aAASM,OAAT,CAAiBP,SAAjB,EAA4BX,KAA5B,EAAmC6D,GAAnC,EAAwCpC,iBAAxC,EAA2D;AACzDd,MAAAA,SAAS,CAACE,OAAV,GAAoBb,KAApB;;AACA,UAAIyB,iBAAJ,EAAuB;AACrBd,QAAAA,SAAS,CAACkE,QAAV,GACEpD,iBAAiB,CAACoD,QAAlB,IAA8BlE,SAAS,CAACkE,QAAxC,IAAoD,CADtD;AAEAlE,QAAAA,SAAS,CAACiE,aAAV,GAA0BnD,iBAAiB,CAACmD,aAAlB,IAAmCf,GAA7D;AACD,OAJD,MAIO;AACLlD,QAAAA,SAAS,CAACiE,aAAV,GAA0Bf,GAA1B;AACD;AACF;;AAED,WAAO;AACLzC,MAAAA,OAAO,EAAEuD,MADJ;AAELzD,MAAAA,OAAO,EAAPA,OAFK;AAGLN,MAAAA,OAAO,EAAPA,OAHK;AAILiE,MAAAA,QAAQ,EAAE1B,MAAM,CAAC0B,QAAP,IAAmB,CAJxB;AAKLhE,MAAAA,OAAO,EAAED,OALJ;AAMLU,MAAAA,QAAQ,EAARA;AANK,KAAP;AAQD,GAjHqB,CAAtB;AAkHD;;AAEM,SAASqF,SAAT,CAAmBzD,UAAnB,EAA+B5B,QAA/B,EAAyC;AAC9C;;AAEA,SAAOkB,eAAe,CAAC,CAAD,EAAI,YAAM;AAC9B;;AACA,QAAMW,MAAM,GAAG;AACbyD,MAAAA,YAAY,EAAE;AADD,KAAf;;AAGA,QAAI1D,UAAJ,EAAgB;AACdO,MAAAA,MAAM,CAACC,IAAP,CAAYR,UAAZ,EAAwBhB,OAAxB,CAAgC,UAACyB,GAAD;AAAA,eAAUR,MAAM,CAACQ,GAAD,CAAN,GAAcT,UAAU,CAACS,GAAD,CAAlC;AAAA,OAAhC;AACD;;AAED,QAAMkD,YAAY,GAAG,CAArB;;AAEA,aAASC,KAAT,CAAenG,SAAf,EAA0BkD,GAA1B,EAA+B;AAAA,UACrBe,aADqB,GACiCjE,SADjC,CACrBiE,aADqB;AAAA,UACNmC,eADM,GACiCpG,SADjC,CACNoG,eADM;AAAA,UACWlG,OADX,GACiCF,SADjC,CACWE,OADX;AAAA,UACoBgE,QADpB,GACiClE,SADjC,CACoBkE,QADpB;AAG7B,UAAMC,SAAS,GAAGC,IAAI,CAACC,GAAL,CAASnB,GAAG,GAAGe,aAAf,EAA8B,EAA9B,CAAlB;AACAjE,MAAAA,SAAS,CAACiE,aAAV,GAA0Bf,GAA1B;AAEA,UAAMmD,EAAE,GAAGjC,IAAI,CAACkC,GAAL,CAAS9D,MAAM,CAACyD,YAAhB,EAA8B9B,SAA9B,CAAX;AACA,UAAMoC,EAAE,GAAI/D,MAAM,CAACyD,YAAP,IAAuB,IAAII,EAA3B,CAAD,IAAoC,IAAI7D,MAAM,CAACyD,YAA/C,CAAX;AAEA,UAAMxB,EAAE,GAAGP,QAAQ,GAAG,IAAtB;AACA,UAAMsC,CAAC,GAAG/B,EAAE,GAAG4B,EAAL,GAAU,IAApB;AACA,UAAMI,CAAC,GAAGvG,OAAO,GAAGuE,EAAE,GAAG8B,EAAzB;AAEAvG,MAAAA,SAAS,CAACE,OAAV,GAAoBuG,CAApB;AACAzG,MAAAA,SAAS,CAACkE,QAAV,GAAqBsC,CAArB;AAEA,UAAIE,gBAAgB,GAAG,IAAvB;;AAEA,UAAIC,KAAK,CAACC,OAAN,CAAcpE,MAAM,CAACqE,KAArB,CAAJ,EAAiC;AAC/B,YAAIT,eAAe,GAAG,CAAlB,IAAuBpG,SAAS,CAACE,OAAV,IAAqBsC,MAAM,CAACqE,KAAP,CAAa,CAAb,CAAhD,EAAiE;AAC/DH,UAAAA,gBAAgB,GAAGlE,MAAM,CAACqE,KAAP,CAAa,CAAb,CAAnB;AACD,SAFD,MAEO,IACLT,eAAe,GAAG,CAAlB,IACApG,SAAS,CAACE,OAAV,IAAqBsC,MAAM,CAACqE,KAAP,CAAa,CAAb,CAFhB,EAGL;AACAH,UAAAA,gBAAgB,GAAGlE,MAAM,CAACqE,KAAP,CAAa,CAAb,CAAnB;AACD;AACF;;AAED,UAAIzC,IAAI,CAAC0B,GAAL,CAASU,CAAT,IAAcN,YAAd,IAA8BQ,gBAAgB,KAAK,IAAvD,EAA6D;AAC3D,YAAIA,gBAAgB,KAAK,IAAzB,EAA+B;AAC7B1G,UAAAA,SAAS,CAACE,OAAV,GAAoBwG,gBAApB;AACD;;AAED,eAAO,IAAP;AACD;AACF;;AAED,aAASnG,OAAT,CAAiBP,SAAjB,EAA4BX,KAA5B,EAAmC6D,GAAnC,EAAwC;AACtClD,MAAAA,SAAS,CAACE,OAAV,GAAoBb,KAApB;AACAW,MAAAA,SAAS,CAACiE,aAAV,GAA0Bf,GAA1B;AACAlD,MAAAA,SAAS,CAACoG,eAAV,GAA4B5D,MAAM,CAAC0B,QAAnC;AACD;;AAED,WAAO;AACLzD,MAAAA,OAAO,EAAE0F,KADJ;AAEL5F,MAAAA,OAAO,EAAPA,OAFK;AAGL2D,MAAAA,QAAQ,EAAE1B,MAAM,CAAC0B,QAAP,IAAmB,CAHxB;AAILvD,MAAAA,QAAQ,EAARA;AAJK,KAAP;AAMD,GA7DqB,CAAtB;AA8DD;;AAEM,SAASmG,SAAT,CAAmBC,OAAnB,EAA4BC,cAA5B,EAA4C;AACjD;;AACA,SAAOnF,eAAe,CAACmF,cAAD,EAAiB,YAAM;AAC3C;;AACA,QAAMC,aAAa,GACjB,OAAOD,cAAP,KAA0B,UAA1B,GAAuCA,cAAc,EAArD,GAA0DA,cAD5D;;AAGA,aAASE,KAAT,CAAelH,SAAf,EAA0BkD,GAA1B,EAA+B;AAAA,UACrBE,SADqB,GACqBpD,SADrB,CACrBoD,SADqB;AAAA,UACV+D,OADU,GACqBnH,SADrB,CACVmH,OADU;AAAA,UACDrG,iBADC,GACqBd,SADrB,CACDc,iBADC;;AAG7B,UAAIoC,GAAG,GAAGE,SAAN,GAAkB2D,OAAtB,EAA+B;AAC7B,YAAI,CAACI,OAAL,EAAc;AACZF,UAAAA,aAAa,CAAC1G,OAAd,CACE0G,aADF,EAEEjH,SAAS,CAACE,OAFZ,EAGEgD,GAHF,EAIEpC,iBAJF;AAMAd,UAAAA,SAAS,CAACc,iBAAV,GAA8B,IAA9B;AACAd,UAAAA,SAAS,CAACmH,OAAV,GAAoB,IAApB;AACD;;AACD,YAAMvF,QAAQ,GAAGqF,aAAa,CAACxG,OAAd,CAAsBwG,aAAtB,EAAqC/D,GAArC,CAAjB;AACAlD,QAAAA,SAAS,CAACE,OAAV,GAAoB+G,aAAa,CAAC/G,OAAlC;AACA,eAAO0B,QAAP;AACD,OAdD,MAcO,IAAId,iBAAJ,EAAuB;AAC5B,YAAMc,SAAQ,GAAGd,iBAAiB,CAACL,OAAlB,CAA0BK,iBAA1B,EAA6CoC,GAA7C,CAAjB;;AACAlD,QAAAA,SAAS,CAACE,OAAV,GAAoBY,iBAAiB,CAACZ,OAAtC;;AACA,YAAI0B,SAAJ,EAAc;AACZ5B,UAAAA,SAAS,CAACc,iBAAV,GAA8B,IAA9B;AACD;AACF;;AACD,aAAO,KAAP;AACD;;AAED,aAASP,OAAT,CAAiBP,SAAjB,EAA4BX,KAA5B,EAAmC6D,GAAnC,EAAwCpC,iBAAxC,EAA2D;AACzDd,MAAAA,SAAS,CAACoD,SAAV,GAAsBF,GAAtB;AACAlD,MAAAA,SAAS,CAACmH,OAAV,GAAoB,KAApB;AACAnH,MAAAA,SAAS,CAACE,OAAV,GAAoBb,KAApB;AACAW,MAAAA,SAAS,CAACc,iBAAV,GAA8BA,iBAA9B;AACD;;AAED,QAAMH,QAAQ,GAAG,SAAXA,QAAW,CAACiB,QAAD,EAAc;AAC7B,UAAIqF,aAAa,CAACtG,QAAlB,EAA4B;AAC1BsG,QAAAA,aAAa,CAACtG,QAAd,CAAuBiB,QAAvB;AACD;AACF,KAJD;;AAMA,WAAO;AACLvB,MAAAA,aAAa,EAAE,IADV;AAELI,MAAAA,OAAO,EAAEyG,KAFJ;AAGL3G,MAAAA,OAAO,EAAPA,OAHK;AAILL,MAAAA,OAAO,EAAE+G,aAAa,CAAC/G,OAJlB;AAKLS,MAAAA,QAAQ,EAARA;AALK,KAAP;AAOD,GApDqB,CAAtB;AAqDD;;AAEM,SAASyG,YAAT,GAAsC;AAC3C;;AAD2C,oCAAbC,WAAa;AAAbA,IAAAA,WAAa;AAAA;;AAE3C,SAAOxF,eAAe,CAACwF,WAAW,CAAC,CAAD,CAAZ,EAAiB,YAAM;AAC3C;;AACA,QAAMC,UAAU,GAAGD,WAAW,CAACE,GAAZ,CAAgB,UAACC,CAAD,EAAO;AACxC,UAAMrI,MAAM,GAAG,OAAOqI,CAAP,KAAa,UAAb,GAA0BA,CAAC,EAA3B,GAAgCA,CAA/C;AACArI,MAAAA,MAAM,CAACyC,QAAP,GAAkB,KAAlB;AACA,aAAOzC,MAAP;AACD,KAJkB,CAAnB;;AAKA,QAAMsI,cAAc,GAAGH,UAAU,CAAC,CAAD,CAAjC;;AAEA,QAAM3G,QAAQ,GAAG,SAAXA,QAAW,CAACiB,QAAD,EAAc;AAC7B,UAAIA,QAAJ,EAAc;AAGZ;AACD;;AAED0F,MAAAA,UAAU,CAAC/F,OAAX,CAAmB,UAACvB,SAAD,EAAe;AAChC,YAAI,OAAOA,SAAS,CAACW,QAAjB,KAA8B,UAA9B,IAA4C,CAACX,SAAS,CAAC4B,QAA3D,EAAqE;AACnE5B,UAAAA,SAAS,CAACW,QAAV,CAAmBiB,QAAnB;AACD;AACF,OAJD;AAKD,KAZD;;AAcA,aAAS8F,QAAT,CAAkB1H,SAAlB,EAA6BkD,GAA7B,EAAkC;AAChC,UAAMyE,WAAW,GAAGL,UAAU,CAACtH,SAAS,CAAC4H,cAAX,CAA9B;AACA,UAAMhG,QAAQ,GAAG+F,WAAW,CAAClH,OAAZ,CAAoBkH,WAApB,EAAiCzE,GAAjC,CAAjB;AACAlD,MAAAA,SAAS,CAACE,OAAV,GAAoByH,WAAW,CAACzH,OAAhC;;AACA,UAAI0B,QAAJ,EAAc;AAEZ,YAAI+F,WAAW,CAAChH,QAAhB,EAA0B;AACxBgH,UAAAA,WAAW,CAAChH,QAAZ,CAAqB,IAArB;AACD;;AACDgH,QAAAA,WAAW,CAAC/F,QAAZ,GAAuB,IAAvB;AACA5B,QAAAA,SAAS,CAAC4H,cAAV,IAA4B,CAA5B;;AACA,YAAI5H,SAAS,CAAC4H,cAAV,GAA2BN,UAAU,CAACO,MAA1C,EAAkD;AAChD,cAAMC,QAAQ,GAAGR,UAAU,CAACtH,SAAS,CAAC4H,cAAX,CAA3B;AACAE,UAAAA,QAAQ,CAACvH,OAAT,CAAiBuH,QAAjB,EAA2BH,WAAW,CAACzH,OAAvC,EAAgDgD,GAAhD,EAAqDyE,WAArD;AACA,iBAAO,KAAP;AACD;;AACD,eAAO,IAAP;AACD;;AACD,aAAO,KAAP;AACD;;AAED,aAASpH,OAAT,CAAiBP,SAAjB,EAA4BX,KAA5B,EAAmC6D,GAAnC,EAAwCpC,iBAAxC,EAA2D;AACzD,UAAIwG,UAAU,CAACO,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,cAAME,KAAK,CACT,sEADS,CAAX;AAGD;;AACD/H,MAAAA,SAAS,CAAC4H,cAAV,GAA2B,CAA3B;;AACA,UAAI9G,iBAAiB,KAAKvB,SAA1B,EAAqC;AACnCuB,QAAAA,iBAAiB,GAAGwG,UAAU,CAACA,UAAU,CAACO,MAAX,GAAoB,CAArB,CAA9B;AACD;;AACDJ,MAAAA,cAAc,CAAClH,OAAf,CAAuBkH,cAAvB,EAAuCpI,KAAvC,EAA8C6D,GAA9C,EAAmDpC,iBAAnD;AACD;;AAED,WAAO;AACLT,MAAAA,aAAa,EAAE,IADV;AAELI,MAAAA,OAAO,EAAEiH,QAFJ;AAGLnH,MAAAA,OAAO,EAAPA,OAHK;AAILqH,MAAAA,cAAc,EAAE,CAJX;AAKL1H,MAAAA,OAAO,EAAEuH,cAAc,CAACvH,OALnB;AAMLS,MAAAA,QAAQ,EAARA;AANK,KAAP;AAQD,GAjEqB,CAAtB;AAkED;;AAEM,SAASqH,UAAT,CACLhB,cADK,EAKL;AACA;;AADA,MAHAiB,YAGA,uEAHe,CAGf;AAAA,MAFAC,OAEA,uEAFU,KAEV;AAAA,MADAvH,QACA;AAGA,SAAOkB,eAAe,CAACmF,cAAD,EAAiB,YAAM;AAC3C;;AAEA,QAAMC,aAAa,GACjB,OAAOD,cAAP,KAA0B,UAA1B,GAAuCA,cAAc,EAArD,GAA0DA,cAD5D;;AAGA,aAASmB,MAAT,CAAgBnI,SAAhB,EAA2BkD,GAA3B,EAAgC;AAC9B,UAAMtB,QAAQ,GAAGqF,aAAa,CAACxG,OAAd,CAAsBwG,aAAtB,EAAqC/D,GAArC,CAAjB;AACAlD,MAAAA,SAAS,CAACE,OAAV,GAAoB+G,aAAa,CAAC/G,OAAlC;;AACA,UAAI0B,QAAJ,EAAc;AACZ5B,QAAAA,SAAS,CAACoI,IAAV,IAAkB,CAAlB;;AAGA,YAAInB,aAAa,CAACtG,QAAlB,EAA4B;AAC1BsG,UAAAA,aAAa,CAACtG,QAAd,CAAuB,IAAvB,EAA4CX,SAAS,CAACE,OAAtD;AACD;;AACD,YAAI+H,YAAY,GAAG,CAAf,IAAoBjI,SAAS,CAACoI,IAAV,IAAkBH,YAA1C,EAAwD;AACtD,iBAAO,IAAP;AACD;;AAED,YAAM9H,UAAU,GAAG+H,OAAO,GACtBjB,aAAa,CAAC/G,OADQ,GAEtBF,SAAS,CAACG,UAFd;;AAGA,YAAI+H,OAAJ,EAAa;AACXjB,UAAAA,aAAa,CAAChH,OAAd,GAAwBD,SAAS,CAACG,UAAlC;AACAH,UAAAA,SAAS,CAACG,UAAV,GAAuBA,UAAvB;AACD;;AACD8G,QAAAA,aAAa,CAAC1G,OAAd,CACE0G,aADF,EAEE9G,UAFF,EAGE+C,GAHF,EAIE+D,aAAa,CAACnG,iBAJhB;AAMA,eAAO,KAAP;AACD;;AACD,aAAO,KAAP;AACD;;AAED,QAAMuH,WAAW,GAAG,SAAdA,WAAc,CAACzG,QAAD,EAAc;AAChC,UAAIjB,QAAJ,EAAc;AACZA,QAAAA,QAAQ,CAACiB,QAAD,CAAR;AACD;;AAED,UAAI,CAACA,QAAD,IAAaqF,aAAa,CAACtG,QAA/B,EAAyC;AACvCsG,QAAAA,aAAa,CAACtG,QAAd,CAAuB,KAAvB;AACD;AACF,KARD;;AAUA,aAASJ,OAAT,CAAiBP,SAAjB,EAA4BX,KAA5B,EAAmC6D,GAAnC,EAAwCpC,iBAAxC,EAA2D;AACzDd,MAAAA,SAAS,CAACG,UAAV,GAAuBd,KAAvB;AACAW,MAAAA,SAAS,CAACoI,IAAV,GAAiB,CAAjB;AACAnB,MAAAA,aAAa,CAAC1G,OAAd,CAAsB0G,aAAtB,EAAqC5H,KAArC,EAA4C6D,GAA5C,EAAiDpC,iBAAjD;AACD;;AAED,WAAO;AACLT,MAAAA,aAAa,EAAE,IADV;AAELI,MAAAA,OAAO,EAAE0H,MAFJ;AAGL5H,MAAAA,OAAO,EAAPA,OAHK;AAIL6H,MAAAA,IAAI,EAAE,CAJD;AAKLlI,MAAAA,OAAO,EAAE+G,aAAa,CAAC/G,OALlB;AAMLS,MAAAA,QAAQ,EAAE0H;AANL,KAAP;AAQD,GA9DqB,CAAtB;AA+DD;;AAGM,SAASnB,KAAT,CAAeH,OAAf,EAAwBC,cAAxB,EAAwC;AAC7C;;AACAsB,EAAAA,OAAO,CAACC,IAAR,CAAa,8DAAb;AACA,SAAOzB,SAAS,CAACC,OAAD,EAAUC,cAAV,CAAhB;AACD;;AAEM,SAASmB,MAAT,CACLnB,cADK,EAKL;AACA;;AADA,MAHAiB,YAGA,uEAHe,CAGf;AAAA,MAFAC,OAEA,uEAFU,KAEV;AAAA,MADAvH,QACA;AAEA2H,EAAAA,OAAO,CAACC,IAAR,CACE,gEADF;AAGA,SAAOP,UAAU,CAAChB,cAAD,EAAiBiB,YAAjB,EAA+BC,OAA/B,EAAwCvH,QAAxC,CAAjB;AACD;;AAEM,SAAS6H,IAAT,CAAcvB,aAAd,EAAgD;AACrD;;AADqD,MAAnBwB,aAAmB,uEAAH,CAAG;AAErDH,EAAAA,OAAO,CAACC,IAAR,CAAa,8DAAb;AACA,SAAOJ,MAAM,CAAClB,aAAD,EAAgB7C,IAAI,CAACsE,KAAL,CAAWD,aAAa,GAAG,CAA3B,CAAhB,EAA+C,IAA/C,CAAb;AACD;;AAEM,SAASf,QAAT,GAAkC;AACvC;;AACAY,EAAAA,OAAO,CAACC,IAAR,CACE,oEADF;AAGA,SAAOnB,YAAY,MAAZ,mBAAP;AACD","sourcesContent":["/* global _WORKLET */\nimport { Easing } from './Easing';\nimport { isColor, convertToHSVA, toRGBA } from './Colors';\nimport NativeReanimated from './NativeReanimated';\n\nlet IN_STYLE_UPDATER = false;\n\nexport function initialUpdaterRun(updater) {\n  IN_STYLE_UPDATER = true;\n  const result = updater();\n  IN_STYLE_UPDATER = false;\n  return result;\n}\n\nexport function transform(value, handler) {\n  'worklet';\n  if (value === undefined) {\n    return undefined;\n  }\n\n  if (typeof value === 'string') {\n    // toInt\n    // TODO handle color\n    const match = value.match(/([A-Za-z]*)(-?\\d*\\.?\\d*)([A-Za-z%]*)/);\n    const prefix = match[1];\n    const suffix = match[3];\n    const number = match[2];\n    handler.__prefix = prefix;\n    handler.__suffix = suffix;\n    return parseFloat(number);\n  }\n\n  // toString if __prefix is available and number otherwise\n  if (handler.__prefix === undefined) {\n    return value;\n  }\n\n  return handler.__prefix + value + handler.__suffix;\n}\n\nexport function transformAnimation(animation) {\n  'worklet';\n  if (!animation) {\n    return;\n  }\n  animation.toValue = transform(animation.toValue, animation);\n  animation.current = transform(animation.current, animation);\n  animation.startValue = transform(animation.startValue, animation);\n}\n\nexport function decorateAnimation(animation) {\n  'worklet';\n  if (animation.isHigherOrder) {\n    return;\n  }\n  const baseOnStart = animation.onStart;\n  const baseOnFrame = animation.onFrame;\n  const animationCopy = Object.assign({}, animation);\n  delete animationCopy.callback;\n\n  const prefNumberSuffOnStart = (\n    animation,\n    value,\n    timestamp,\n    previousAnimation\n  ) => {\n    const val = transform(value, animation);\n    transformAnimation(animation);\n    if (previousAnimation !== animation) transformAnimation(previousAnimation);\n\n    baseOnStart(animation, val, timestamp, previousAnimation);\n\n    transformAnimation(animation);\n    if (previousAnimation !== animation) transformAnimation(previousAnimation);\n  };\n  const prefNumberSuffOnFrame = (animation, timestamp) => {\n    transformAnimation(animation);\n\n    const res = baseOnFrame(animation, timestamp);\n\n    transformAnimation(animation);\n    return res;\n  };\n\n  const tab = ['H', 'S', 'V', 'A'];\n  const colorOnStart = (animation, value, timestamp, previousAnimation) => {\n    let HSVAValue;\n    let HSVACurrent;\n    let HSVAToValue;\n    const res = [];\n    if (isColor(value)) {\n      HSVACurrent = convertToHSVA(animation.current);\n      HSVAValue = convertToHSVA(value);\n      if (animation.toValue) {\n        HSVAToValue = convertToHSVA(animation.toValue);\n      }\n    }\n    tab.forEach((i, index) => {\n      animation[i] = Object.assign({}, animationCopy);\n      animation[i].current = HSVACurrent[index];\n      animation[i].toValue = HSVAToValue ? HSVAToValue[index] : undefined;\n      animation[i].onStart(\n        animation[i],\n        HSVAValue[index],\n        timestamp,\n        previousAnimation ? previousAnimation[i] : undefined\n      );\n      res.push(animation[i].current);\n    });\n\n    animation.current = toRGBA(res);\n  };\n\n  const colorOnFrame = (animation, timestamp) => {\n    const HSVACurrent = convertToHSVA(animation.current);\n    const res = [];\n    let finished = true;\n    tab.forEach((i, index) => {\n      animation[i].current = HSVACurrent[index];\n      finished &= animation[i].onFrame(animation[i], timestamp);\n      res.push(animation[i].current);\n    });\n\n    animation.current = toRGBA(res);\n    return finished;\n  };\n\n  animation.onStart = (animation, value, timestamp, previousAnimation) => {\n    if (isColor(value)) {\n      colorOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = colorOnFrame;\n      return;\n    } else if (typeof value === 'string') {\n      prefNumberSuffOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = prefNumberSuffOnFrame;\n      return;\n    }\n    baseOnStart(animation, value, timestamp, previousAnimation);\n  };\n}\n\nexport function defineAnimation(starting, factory) {\n  'worklet';\n  if (IN_STYLE_UPDATER) {\n    return starting;\n  }\n  const create = () => {\n    'worklet';\n    const animation = factory();\n    decorateAnimation(animation);\n    return animation;\n  };\n\n  if (_WORKLET || !NativeReanimated.native) {\n    return create();\n  }\n  return create;\n}\n\nexport function cancelAnimation(sharedValue) {\n  'worklet';\n  // setting the current value cancels the animation if one is currently running\n  sharedValue.value = sharedValue.value; // eslint-disable-line no-self-assign\n}\n\nexport function withTiming(toValue, userConfig, callback) {\n  'worklet';\n\n  return defineAnimation(toValue, () => {\n    'worklet';\n    const config = {\n      duration: 300,\n      easing: Easing.inOut(Easing.quad),\n    };\n    if (userConfig) {\n      Object.keys(userConfig).forEach((key) => (config[key] = userConfig[key]));\n    }\n\n    function timing(animation, now) {\n      const { toValue, progress, startTime, current } = animation;\n\n      const runtime = now - startTime;\n\n      if (runtime >= config.duration) {\n        // reset startTime to avoid reusing finished animation config in `start` method\n        animation.startTime = 0;\n        animation.current = toValue;\n        return true;\n      }\n\n      const newProgress = config.easing(runtime / config.duration);\n\n      const dist =\n        ((toValue - current) * (newProgress - progress)) / (1 - progress);\n      animation.current += dist;\n      animation.progress = newProgress;\n      return false;\n    }\n\n    function onStart(animation, value, now, previousAnimation) {\n      if (\n        previousAnimation &&\n        previousAnimation.type === 'timing' &&\n        previousAnimation.toValue === toValue &&\n        previousAnimation.startTime\n      ) {\n        // to maintain continuity of timing animations we check if we are starting\n        // new timing over the old one with the same parameters. If so, we want\n        // to copy animation timeline properties\n        animation.startTime = previousAnimation.startTime;\n        animation.progress = previousAnimation.progress;\n      } else {\n        animation.startTime = now;\n        animation.progress = 0;\n      }\n      animation.current = value;\n    }\n\n    return {\n      type: 'timing',\n      onFrame: timing,\n      onStart,\n      progress: 0,\n      toValue,\n      current: toValue,\n      callback,\n    };\n  });\n}\n\nexport function withSpring(toValue, userConfig, callback) {\n  'worklet';\n\n  return defineAnimation(toValue, () => {\n    'worklet';\n\n    // TODO: figure out why we can't use spread or Object.assign here\n    // when user config is \"frozen object\" we can't enumerate it (perhaps\n    // something is wrong with the object prototype).\n    const config = {\n      damping: 10,\n      mass: 1,\n      stiffness: 100,\n      overshootClamping: false,\n      restDisplacementThreshold: 0.01,\n      restSpeedThreshold: 2,\n    };\n    if (userConfig) {\n      Object.keys(userConfig).forEach((key) => (config[key] = userConfig[key]));\n    }\n\n    function spring(animation, now) {\n      const { toValue, lastTimestamp, current, velocity } = animation;\n\n      const deltaTime = Math.min(now - lastTimestamp, 64);\n      animation.lastTimestamp = now;\n\n      const c = config.damping;\n      const m = config.mass;\n      const k = config.stiffness;\n\n      const v0 = -velocity;\n      const x0 = toValue - current;\n\n      const zeta = c / (2 * Math.sqrt(k * m)); // damping ratio\n      const omega0 = Math.sqrt(k / m); // undamped angular frequency of the oscillator (rad/ms)\n      const omega1 = omega0 * Math.sqrt(1 - zeta ** 2); // exponential decay\n\n      const t = deltaTime / 1000;\n\n      const sin1 = Math.sin(omega1 * t);\n      const cos1 = Math.cos(omega1 * t);\n\n      // under damped\n      const underDampedEnvelope = Math.exp(-zeta * omega0 * t);\n      const underDampedFrag1 =\n        underDampedEnvelope *\n        (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);\n\n      const underDampedPosition = toValue - underDampedFrag1;\n      // This looks crazy -- it's actually just the derivative of the oscillation function\n      const underDampedVelocity =\n        zeta * omega0 * underDampedFrag1 -\n        underDampedEnvelope *\n          (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);\n\n      // critically damped\n      const criticallyDampedEnvelope = Math.exp(-omega0 * t);\n      const criticallyDampedPosition =\n        toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);\n\n      const criticallyDampedVelocity =\n        criticallyDampedEnvelope *\n        (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);\n\n      const isOvershooting = () => {\n        if (config.overshootClamping && config.stiffness !== 0) {\n          return current < toValue\n            ? animation.current > toValue\n            : animation.current < toValue;\n        } else {\n          return false;\n        }\n      };\n\n      const isVelocity = Math.abs(velocity) < config.restSpeedThreshold;\n      const isDisplacement =\n        config.stiffness === 0 ||\n        Math.abs(toValue - current) < config.restDisplacementThreshold;\n\n      if (zeta < 1) {\n        animation.current = underDampedPosition;\n        animation.velocity = underDampedVelocity;\n      } else {\n        animation.current = criticallyDampedPosition;\n        animation.velocity = criticallyDampedVelocity;\n      }\n\n      if (isOvershooting() || (isVelocity && isDisplacement)) {\n        if (config.stiffness !== 0) {\n          animation.velocity = 0;\n          animation.current = toValue;\n        }\n        return true;\n      }\n    }\n\n    function onStart(animation, value, now, previousAnimation) {\n      animation.current = value;\n      if (previousAnimation) {\n        animation.velocity =\n          previousAnimation.velocity || animation.velocity || 0;\n        animation.lastTimestamp = previousAnimation.lastTimestamp || now;\n      } else {\n        animation.lastTimestamp = now;\n      }\n    }\n\n    return {\n      onFrame: spring,\n      onStart,\n      toValue,\n      velocity: config.velocity || 0,\n      current: toValue,\n      callback,\n    };\n  });\n}\n\nexport function withDecay(userConfig, callback) {\n  'worklet';\n\n  return defineAnimation(0, () => {\n    'worklet';\n    const config = {\n      deceleration: 0.998,\n    };\n    if (userConfig) {\n      Object.keys(userConfig).forEach((key) => (config[key] = userConfig[key]));\n    }\n\n    const VELOCITY_EPS = 5;\n\n    function decay(animation, now) {\n      const { lastTimestamp, initialVelocity, current, velocity } = animation;\n\n      const deltaTime = Math.min(now - lastTimestamp, 64);\n      animation.lastTimestamp = now;\n\n      const kv = Math.pow(config.deceleration, deltaTime);\n      const kx = (config.deceleration * (1 - kv)) / (1 - config.deceleration);\n\n      const v0 = velocity / 1000;\n      const v = v0 * kv * 1000;\n      const x = current + v0 * kx;\n\n      animation.current = x;\n      animation.velocity = v;\n\n      let toValueIsReached = null;\n\n      if (Array.isArray(config.clamp)) {\n        if (initialVelocity < 0 && animation.current <= config.clamp[0]) {\n          toValueIsReached = config.clamp[0];\n        } else if (\n          initialVelocity > 0 &&\n          animation.current >= config.clamp[1]\n        ) {\n          toValueIsReached = config.clamp[1];\n        }\n      }\n\n      if (Math.abs(v) < VELOCITY_EPS || toValueIsReached !== null) {\n        if (toValueIsReached !== null) {\n          animation.current = toValueIsReached;\n        }\n\n        return true;\n      }\n    }\n\n    function onStart(animation, value, now) {\n      animation.current = value;\n      animation.lastTimestamp = now;\n      animation.initialVelocity = config.velocity;\n    }\n\n    return {\n      onFrame: decay,\n      onStart,\n      velocity: config.velocity || 0,\n      callback,\n    };\n  });\n}\n\nexport function withDelay(delayMs, _nextAnimation) {\n  'worklet';\n  return defineAnimation(_nextAnimation, () => {\n    'worklet';\n    const nextAnimation =\n      typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;\n\n    function delay(animation, now) {\n      const { startTime, started, previousAnimation } = animation;\n\n      if (now - startTime > delayMs) {\n        if (!started) {\n          nextAnimation.onStart(\n            nextAnimation,\n            animation.current,\n            now,\n            previousAnimation\n          );\n          animation.previousAnimation = null;\n          animation.started = true;\n        }\n        const finished = nextAnimation.onFrame(nextAnimation, now);\n        animation.current = nextAnimation.current;\n        return finished;\n      } else if (previousAnimation) {\n        const finished = previousAnimation.onFrame(previousAnimation, now);\n        animation.current = previousAnimation.current;\n        if (finished) {\n          animation.previousAnimation = null;\n        }\n      }\n      return false;\n    }\n\n    function onStart(animation, value, now, previousAnimation) {\n      animation.startTime = now;\n      animation.started = false;\n      animation.current = value;\n      animation.previousAnimation = previousAnimation;\n    }\n\n    const callback = (finished) => {\n      if (nextAnimation.callback) {\n        nextAnimation.callback(finished);\n      }\n    };\n\n    return {\n      isHigherOrder: true,\n      onFrame: delay,\n      onStart,\n      current: nextAnimation.current,\n      callback,\n    };\n  });\n}\n\nexport function withSequence(..._animations) {\n  'worklet';\n  return defineAnimation(_animations[0], () => {\n    'worklet';\n    const animations = _animations.map((a) => {\n      const result = typeof a === 'function' ? a() : a;\n      result.finished = false;\n      return result;\n    });\n    const firstAnimation = animations[0];\n\n    const callback = (finished) => {\n      if (finished) {\n        // we want to call the callback after every single animation\n        // not after all of them\n        return;\n      }\n      // this is going to be called only if sequence has been cancelled\n      animations.forEach((animation) => {\n        if (typeof animation.callback === 'function' && !animation.finished) {\n          animation.callback(finished);\n        }\n      });\n    };\n\n    function sequence(animation, now) {\n      const currentAnim = animations[animation.animationIndex];\n      const finished = currentAnim.onFrame(currentAnim, now);\n      animation.current = currentAnim.current;\n      if (finished) {\n        // we want to call the callback after every single animation\n        if (currentAnim.callback) {\n          currentAnim.callback(true /* finished */);\n        }\n        currentAnim.finished = true;\n        animation.animationIndex += 1;\n        if (animation.animationIndex < animations.length) {\n          const nextAnim = animations[animation.animationIndex];\n          nextAnim.onStart(nextAnim, currentAnim.current, now, currentAnim);\n          return false;\n        }\n        return true;\n      }\n      return false;\n    }\n\n    function onStart(animation, value, now, previousAnimation) {\n      if (animations.length === 1) {\n        throw Error(\n          'withSequence() animation require more than one animation as argument'\n        );\n      }\n      animation.animationIndex = 0;\n      if (previousAnimation === undefined) {\n        previousAnimation = animations[animations.length - 1];\n      }\n      firstAnimation.onStart(firstAnimation, value, now, previousAnimation);\n    }\n\n    return {\n      isHigherOrder: true,\n      onFrame: sequence,\n      onStart,\n      animationIndex: 0,\n      current: firstAnimation.current,\n      callback,\n    };\n  });\n}\n\nexport function withRepeat(\n  _nextAnimation,\n  numberOfReps = 2,\n  reverse = false,\n  callback\n) {\n  'worklet';\n\n  return defineAnimation(_nextAnimation, () => {\n    'worklet';\n\n    const nextAnimation =\n      typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;\n\n    function repeat(animation, now) {\n      const finished = nextAnimation.onFrame(nextAnimation, now);\n      animation.current = nextAnimation.current;\n      if (finished) {\n        animation.reps += 1;\n        // call inner animation's callback on every repetition\n        // as the second argument the animation's current value is passed\n        if (nextAnimation.callback) {\n          nextAnimation.callback(true /* finished */, animation.current);\n        }\n        if (numberOfReps > 0 && animation.reps >= numberOfReps) {\n          return true;\n        }\n\n        const startValue = reverse\n          ? nextAnimation.current\n          : animation.startValue;\n        if (reverse) {\n          nextAnimation.toValue = animation.startValue;\n          animation.startValue = startValue;\n        }\n        nextAnimation.onStart(\n          nextAnimation,\n          startValue,\n          now,\n          nextAnimation.previousAnimation\n        );\n        return false;\n      }\n      return false;\n    }\n\n    const repCallback = (finished) => {\n      if (callback) {\n        callback(finished);\n      }\n      // when cancelled call inner animation's callback\n      if (!finished && nextAnimation.callback) {\n        nextAnimation.callback(false /* finished */);\n      }\n    };\n\n    function onStart(animation, value, now, previousAnimation) {\n      animation.startValue = value;\n      animation.reps = 0;\n      nextAnimation.onStart(nextAnimation, value, now, previousAnimation);\n    }\n\n    return {\n      isHigherOrder: true,\n      onFrame: repeat,\n      onStart,\n      reps: 0,\n      current: nextAnimation.current,\n      callback: repCallback,\n    };\n  });\n}\n\n/* Deprecated section, kept for backward compatibility. Will be removed soon */\nexport function delay(delayMs, _nextAnimation) {\n  'worklet';\n  console.warn('Method `delay` is deprecated. Please use `withDelay` instead');\n  return withDelay(delayMs, _nextAnimation);\n}\n\nexport function repeat(\n  _nextAnimation,\n  numberOfReps = 2,\n  reverse = false,\n  callback\n) {\n  'worklet';\n  console.warn(\n    'Method `repeat` is deprecated. Please use `withRepeat` instead'\n  );\n  return withRepeat(_nextAnimation, numberOfReps, reverse, callback);\n}\n\nexport function loop(nextAnimation, numberOfLoops = 1) {\n  'worklet';\n  console.warn('Method `loop` is deprecated. Please use `withRepeat` instead');\n  return repeat(nextAnimation, Math.round(numberOfLoops * 2), true);\n}\n\nexport function sequence(..._animations) {\n  'worklet';\n  console.warn(\n    'Method `sequence` is deprecated. Please use `withSequence` instead'\n  );\n  return withSequence(..._animations);\n}\n/* Deprecated section end */\n"]},"metadata":{},"sourceType":"script"}