{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.interpolate = interpolate;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _interpolate = _interopRequireWildcard(require(\"../derived/interpolate\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction getVal(config) {\n  'worklet';\n\n  var type = config.type,\n      coef = config.coef,\n      val = config.val,\n      ll = config.ll,\n      rr = config.rr,\n      x = config.x;\n\n  switch (type) {\n    case _interpolate.Extrapolate.IDENTITY:\n      return x;\n\n    case _interpolate.Extrapolate.CLAMP:\n      if (coef * val < coef * ll) {\n        return ll;\n      }\n\n      return rr;\n\n    case _interpolate.Extrapolate.EXTEND:\n    default:\n      return val;\n  }\n}\n\nfunction isExtrapolate(value) {\n  'worklet';\n\n  return value === _interpolate.Extrapolate.EXTEND || value === _interpolate.Extrapolate.CLAMP || value === _interpolate.Extrapolate.IDENTITY;\n}\n\nfunction validateType(type) {\n  'worklet';\n\n  var _type;\n\n  var EXTRAPOLATE_ERROR_MSG = \"Reanimated: config object is not valid, please provide valid config, for example:\\n    interpolate(value, [inputRange], [outputRange], {\\n    extrapolateLeft: 'clamp',\\n    extrapolateRight: 'extend',\\n  })\";\n\n  var EXTRAPOLATE_ERROR = function EXTRAPOLATE_ERROR(extrapolate) {\n    return \"Reanimated: not supported value for \\\"\" + extrapolate + \"\\\" \\nSupported values: [\\\"extend\\\", \\\"clamp\\\", \\\"identity\\\"]\\n Valid example:\\n    interpolate(value, [inputRange], [outputRange], {\\n      \" + extrapolate + \": 'clamp',\\n  })\";\n  };\n\n  type = (_type = type) != null ? _type : 'extend';\n  var hasExtrapolateLeft = type.hasOwnProperty('extrapolateLeft');\n  var hasExtrapolateRight = type.hasOwnProperty('extrapolateRight');\n\n  if (typeof type === 'object' && (Object.keys(type).length === 2 && !(hasExtrapolateLeft && hasExtrapolateRight) || Object.keys(type).length === 1 && !(hasExtrapolateLeft || hasExtrapolateRight) || Object.keys(type).length > 2)) {\n    throw new Error(EXTRAPOLATE_ERROR_MSG);\n  }\n\n  if (typeof type === 'object') {\n    if (hasExtrapolateLeft && !isExtrapolate(type.extrapolateLeft)) {\n      throw new Error(EXTRAPOLATE_ERROR('extrapolateLeft'));\n    }\n\n    if (hasExtrapolateRight && !isExtrapolate(type.extrapolateRight)) {\n      throw new Error(EXTRAPOLATE_ERROR('extrapolateRight'));\n    }\n  }\n\n  if (typeof type === 'string' && !isExtrapolate(type)) {\n    throw new Error(\"Reanimated: not supported value for \\\"interpolate\\\" \\nSupported values: [\\\"extend\\\", \\\"clamp\\\", \\\"identity\\\"]\\n Valid example:\\n       interpolate(value, [inputRange], [outputRange], \\\"clamp\\\")\");\n  }\n}\n\nfunction internalInterpolate(x, l, r, ll, rr, type) {\n  'worklet';\n\n  if (r - l === 0) return ll;\n  var progress = (x - l) / (r - l);\n  var val = ll + progress * (rr - ll);\n  var coef = rr >= ll ? 1 : -1;\n  var config = {\n    type: type,\n    coef: coef,\n    val: val,\n    ll: ll,\n    rr: rr,\n    x: x\n  };\n  validateType(type);\n\n  if (typeof type === 'object') {\n    if (coef * val < coef * ll) {\n      return getVal((0, _extends2.default)(config, {\n        type: type.extrapolateLeft\n      }));\n    } else if (coef * val > coef * ll) {\n      return getVal((0, _extends2.default)(config, {\n        type: type.extrapolateRight\n      }));\n    }\n  }\n\n  if (coef * val < coef * ll || coef * val > coef * rr) {\n    return getVal(config);\n  }\n\n  return val;\n}\n\nfunction interpolate(x, input, output, type) {\n  'worklet';\n\n  if (x && x.__nodeID) {\n    console.warn(\"interpolate() was renamed to interpolateNode() in Reanimated 2. Please use interpolateNode() instead\");\n    return _interpolate.default.apply(undefined, arguments);\n  }\n\n  var length = input.length;\n  var narrowedInput = [];\n\n  if (x < input[0]) {\n    narrowedInput = [input[0], input[1], output[0], output[1]];\n  } else if (x > input[length - 1]) {\n    narrowedInput = [input[length - 2], input[length - 1], output[length - 2], output[length - 1]];\n  } else {\n    for (var i = 1; i < length; ++i) {\n      if (x <= input[i]) {\n        narrowedInput = [input[i - 1], input[i], output[i - 1], output[i]];\n        break;\n      }\n    }\n  }\n\n  return internalInterpolate.apply({}, [x].concat(narrowedInput).concat(type));\n}","map":{"version":3,"sources":["/Users/user/projects/HarlemHaberdashery/node_modules/react-native-reanimated/src/reanimated2/interpolation.js"],"names":["getVal","config","type","coef","val","ll","rr","x","Extrapolate","IDENTITY","CLAMP","EXTEND","isExtrapolate","value","validateType","EXTRAPOLATE_ERROR_MSG","EXTRAPOLATE_ERROR","extrapolate","hasExtrapolateLeft","hasOwnProperty","hasExtrapolateRight","Object","keys","length","Error","extrapolateLeft","extrapolateRight","internalInterpolate","l","r","progress","interpolate","input","output","__nodeID","console","warn","interpolateNode","apply","undefined","arguments","narrowedInput","i","concat"],"mappings":";;;;;;;;;AAAA;;;;;;AAIA,SAASA,MAAT,CAAgBC,MAAhB,EAAwB;AACtB;;AADsB,MAGdC,IAHc,GAGiBD,MAHjB,CAGdC,IAHc;AAAA,MAGRC,IAHQ,GAGiBF,MAHjB,CAGRE,IAHQ;AAAA,MAGFC,GAHE,GAGiBH,MAHjB,CAGFG,GAHE;AAAA,MAGGC,EAHH,GAGiBJ,MAHjB,CAGGI,EAHH;AAAA,MAGOC,EAHP,GAGiBL,MAHjB,CAGOK,EAHP;AAAA,MAGWC,CAHX,GAGiBN,MAHjB,CAGWM,CAHX;;AAKtB,UAAQL,IAAR;AACE,SAAKM,yBAAYC,QAAjB;AACE,aAAOF,CAAP;;AACF,SAAKC,yBAAYE,KAAjB;AACE,UAAIP,IAAI,GAAGC,GAAP,GAAaD,IAAI,GAAGE,EAAxB,EAA4B;AAC1B,eAAOA,EAAP;AACD;;AACD,aAAOC,EAAP;;AACF,SAAKE,yBAAYG,MAAjB;AACA;AACE,aAAOP,GAAP;AAVJ;AAYD;;AAED,SAASQ,aAAT,CAAuBC,KAAvB,EAA8B;AAC5B;;AAEA,SACEA,KAAK,KAAKL,yBAAYG,MAAtB,IACAE,KAAK,KAAKL,yBAAYE,KADtB,IAEAG,KAAK,KAAKL,yBAAYC,QAHxB;AAKD;;AAED,SAASK,YAAT,CAAsBZ,IAAtB,EAA4B;AAC1B;;AAD0B;;AAG1B,MAAMa,qBAAqB,mNAA3B;;AAMA,MAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,CACxBC,WADwB;AAAA,sDAEmBA,WAFnB,oJAIpBA,WAJoB;AAAA,GAA1B;;AAOAf,EAAAA,IAAI,YAAGA,IAAH,oBAAW,QAAf;AAGA,MAAMgB,kBAAkB,GAAGhB,IAAI,CAACiB,cAAL,CAAoB,iBAApB,CAA3B;AAEA,MAAMC,mBAAmB,GAAGlB,IAAI,CAACiB,cAAL,CAAoB,kBAApB,CAA5B;;AAEA,MACE,OAAOjB,IAAP,KAAgB,QAAhB,KACEmB,MAAM,CAACC,IAAP,CAAYpB,IAAZ,EAAkBqB,MAAlB,KAA6B,CAA7B,IACA,EAAEL,kBAAkB,IAAIE,mBAAxB,CADD,IAEEC,MAAM,CAACC,IAAP,CAAYpB,IAAZ,EAAkBqB,MAAlB,KAA6B,CAA7B,IACC,EAAEL,kBAAkB,IAAIE,mBAAxB,CAHH,IAICC,MAAM,CAACC,IAAP,CAAYpB,IAAZ,EAAkBqB,MAAlB,GAA2B,CAL7B,CADF,EAOE;AACA,UAAM,IAAIC,KAAJ,CAAUT,qBAAV,CAAN;AACD;;AAED,MAAI,OAAOb,IAAP,KAAgB,QAApB,EAA8B;AAC5B,QAAIgB,kBAAkB,IAAI,CAACN,aAAa,CAACV,IAAI,CAACuB,eAAN,CAAxC,EAAgE;AAC9D,YAAM,IAAID,KAAJ,CAAUR,iBAAiB,CAAC,iBAAD,CAA3B,CAAN;AACD;;AAED,QAAII,mBAAmB,IAAI,CAACR,aAAa,CAACV,IAAI,CAACwB,gBAAN,CAAzC,EAAkE;AAChE,YAAM,IAAIF,KAAJ,CAAUR,iBAAiB,CAAC,kBAAD,CAA3B,CAAN;AACD;AACF;;AAED,MAAI,OAAOd,IAAP,KAAgB,QAAhB,IAA4B,CAACU,aAAa,CAACV,IAAD,CAA9C,EAAsD;AACpD,UAAM,IAAIsB,KAAJ,qMAAN;AAID;AACF;;AAID,SAASG,mBAAT,CAA6BpB,CAA7B,EAAgCqB,CAAhC,EAAmCC,CAAnC,EAAsCxB,EAAtC,EAA0CC,EAA1C,EAA8CJ,IAA9C,EAAoD;AAClD;;AACA,MAAI2B,CAAC,GAAGD,CAAJ,KAAU,CAAd,EAAiB,OAAOvB,EAAP;AACjB,MAAMyB,QAAQ,GAAG,CAACvB,CAAC,GAAGqB,CAAL,KAAWC,CAAC,GAAGD,CAAf,CAAjB;AACA,MAAMxB,GAAG,GAAGC,EAAE,GAAGyB,QAAQ,IAAIxB,EAAE,GAAGD,EAAT,CAAzB;AACA,MAAMF,IAAI,GAAGG,EAAE,IAAID,EAAN,GAAW,CAAX,GAAe,CAAC,CAA7B;AAEA,MAAMJ,MAAM,GAAG;AAAEC,IAAAA,IAAI,EAAJA,IAAF;AAAQC,IAAAA,IAAI,EAAJA,IAAR;AAAcC,IAAAA,GAAG,EAAHA,GAAd;AAAmBC,IAAAA,EAAE,EAAFA,EAAnB;AAAuBC,IAAAA,EAAE,EAAFA,EAAvB;AAA2BC,IAAAA,CAAC,EAADA;AAA3B,GAAf;AAEAO,EAAAA,YAAY,CAACZ,IAAD,CAAZ;;AAEA,MAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,QAAIC,IAAI,GAAGC,GAAP,GAAaD,IAAI,GAAGE,EAAxB,EAA4B;AAC1B,aAAOL,MAAM,CAAC,uBAAcC,MAAd,EAAsB;AAAEC,QAAAA,IAAI,EAAEA,IAAI,CAACuB;AAAb,OAAtB,CAAD,CAAb;AACD,KAFD,MAEO,IAAItB,IAAI,GAAGC,GAAP,GAAaD,IAAI,GAAGE,EAAxB,EAA4B;AACjC,aAAOL,MAAM,CAAC,uBAAcC,MAAd,EAAsB;AAAEC,QAAAA,IAAI,EAAEA,IAAI,CAACwB;AAAb,OAAtB,CAAD,CAAb;AACD;AACF;;AAED,MAAIvB,IAAI,GAAGC,GAAP,GAAaD,IAAI,GAAGE,EAApB,IAA0BF,IAAI,GAAGC,GAAP,GAAaD,IAAI,GAAGG,EAAlD,EAAsD;AACpD,WAAON,MAAM,CAACC,MAAD,CAAb;AACD;;AAED,SAAOG,GAAP;AACD;;AAEM,SAAS2B,WAAT,CAAqBxB,CAArB,EAAwByB,KAAxB,EAA+BC,MAA/B,EAAuC/B,IAAvC,EAA6C;AAClD;;AACA,MAAIK,CAAC,IAAIA,CAAC,CAAC2B,QAAX,EAAqB;AACnBC,IAAAA,OAAO,CAACC,IAAR;AACA,WAAOC,qBAAgBC,KAAhB,CAAsBC,SAAtB,EAAiCC,SAAjC,CAAP;AACD;;AAED,MAAMjB,MAAM,GAAGS,KAAK,CAACT,MAArB;AACA,MAAIkB,aAAa,GAAG,EAApB;;AACA,MAAIlC,CAAC,GAAGyB,KAAK,CAAC,CAAD,CAAb,EAAkB;AAChBS,IAAAA,aAAa,GAAG,CAACT,KAAK,CAAC,CAAD,CAAN,EAAWA,KAAK,CAAC,CAAD,CAAhB,EAAqBC,MAAM,CAAC,CAAD,CAA3B,EAAgCA,MAAM,CAAC,CAAD,CAAtC,CAAhB;AACD,GAFD,MAEO,IAAI1B,CAAC,GAAGyB,KAAK,CAACT,MAAM,GAAG,CAAV,CAAb,EAA2B;AAChCkB,IAAAA,aAAa,GAAG,CACdT,KAAK,CAACT,MAAM,GAAG,CAAV,CADS,EAEdS,KAAK,CAACT,MAAM,GAAG,CAAV,CAFS,EAGdU,MAAM,CAACV,MAAM,GAAG,CAAV,CAHQ,EAIdU,MAAM,CAACV,MAAM,GAAG,CAAV,CAJQ,CAAhB;AAMD,GAPM,MAOA;AACL,SAAK,IAAImB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnB,MAApB,EAA4B,EAAEmB,CAA9B,EAAiC;AAC/B,UAAInC,CAAC,IAAIyB,KAAK,CAACU,CAAD,CAAd,EAAmB;AACjBD,QAAAA,aAAa,GAAG,CAACT,KAAK,CAACU,CAAC,GAAG,CAAL,CAAN,EAAeV,KAAK,CAACU,CAAD,CAApB,EAAyBT,MAAM,CAACS,CAAC,GAAG,CAAL,CAA/B,EAAwCT,MAAM,CAACS,CAAD,CAA9C,CAAhB;AACA;AACD;AACF;AACF;;AACD,SAAOf,mBAAmB,CAACW,KAApB,CAA0B,EAA1B,EAA8B,CAAC/B,CAAD,EAAIoC,MAAJ,CAAWF,aAAX,EAA0BE,MAA1B,CAAiCzC,IAAjC,CAA9B,CAAP;AACD","sourcesContent":["import interpolateNode,{\n  Extrapolate\n} from '../derived/interpolate';\n\nfunction getVal(config) {\n  'worklet';\n\n  const { type, coef, val, ll, rr, x } = config;\n\n  switch (type) {\n    case Extrapolate.IDENTITY:\n      return x;\n    case Extrapolate.CLAMP:\n      if (coef * val < coef * ll) {\n        return ll;\n      }\n      return rr;\n    case Extrapolate.EXTEND:\n    default:\n      return val;\n  }\n}\n\nfunction isExtrapolate(value) {\n  'worklet';\n\n  return (\n    value === Extrapolate.EXTEND ||\n    value === Extrapolate.CLAMP ||\n    value === Extrapolate.IDENTITY\n  );\n}\n\nfunction validateType(type) {\n  'worklet';\n\n  const EXTRAPOLATE_ERROR_MSG = `Reanimated: config object is not valid, please provide valid config, for example:\n    interpolate(value, [inputRange], [outputRange], {\n    extrapolateLeft: 'clamp',\n    extrapolateRight: 'extend',\n  })`;\n\n  const EXTRAPOLATE_ERROR = (\n    extrapolate\n  ) => `Reanimated: not supported value for \"${extrapolate}\" \\nSupported values: [\"extend\", \"clamp\", \"identity\"]\\n Valid example:\n    interpolate(value, [inputRange], [outputRange], {\n      ${extrapolate}: 'clamp',\n  })`;\n\n  type = type ?? 'extend';\n\n  // eslint-disable-next-line no-prototype-builtins\n  const hasExtrapolateLeft = type.hasOwnProperty('extrapolateLeft');\n  // eslint-disable-next-line no-prototype-builtins\n  const hasExtrapolateRight = type.hasOwnProperty('extrapolateRight');\n\n  if (\n    typeof type === 'object' &&\n    ((Object.keys(type).length === 2 &&\n      !(hasExtrapolateLeft && hasExtrapolateRight)) ||\n      (Object.keys(type).length === 1 &&\n        !(hasExtrapolateLeft || hasExtrapolateRight)) ||\n      Object.keys(type).length > 2)\n  ) {\n    throw new Error(EXTRAPOLATE_ERROR_MSG);\n  }\n\n  if (typeof type === 'object') {\n    if (hasExtrapolateLeft && !isExtrapolate(type.extrapolateLeft)) {\n      throw new Error(EXTRAPOLATE_ERROR('extrapolateLeft'));\n    }\n\n    if (hasExtrapolateRight && !isExtrapolate(type.extrapolateRight)) {\n      throw new Error(EXTRAPOLATE_ERROR('extrapolateRight'));\n    }\n  }\n\n  if (typeof type === 'string' && !isExtrapolate(type)) {\n    throw new Error(\n      `Reanimated: not supported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\"]\\n Valid example:\n       interpolate(value, [inputRange], [outputRange], \"clamp\")`\n    );\n  }\n}\n\n// TODO: support default values in worklets:\n// e.g. function interpolate(x, input, output, type = Extrapolate.CLAMP)\nfunction internalInterpolate(x, l, r, ll, rr, type) {\n  'worklet';\n  if (r - l === 0) return ll;\n  const progress = (x - l) / (r - l);\n  const val = ll + progress * (rr - ll);\n  const coef = rr >= ll ? 1 : -1;\n\n  const config = { type, coef, val, ll, rr, x };\n\n  validateType(type);\n\n  if (typeof type === 'object') {\n    if (coef * val < coef * ll) {\n      return getVal(Object.assign(config, { type: type.extrapolateLeft }));\n    } else if (coef * val > coef * ll) {\n      return getVal(Object.assign(config, { type: type.extrapolateRight }));\n    }\n  }\n\n  if (coef * val < coef * ll || coef * val > coef * rr) {\n    return getVal(config);\n  }\n\n  return val;\n}\n\nexport function interpolate(x, input, output, type) {\n  'worklet';\n  if (x && x.__nodeID) {\n    console.warn(`interpolate() was renamed to interpolateNode() in Reanimated 2. Please use interpolateNode() instead`);\n    return interpolateNode.apply(undefined, arguments);\n  }\n\n  const length = input.length;\n  let narrowedInput = [];\n  if (x < input[0]) {\n    narrowedInput = [input[0], input[1], output[0], output[1]];\n  } else if (x > input[length - 1]) {\n    narrowedInput = [\n      input[length - 2],\n      input[length - 1],\n      output[length - 2],\n      output[length - 1],\n    ];\n  } else {\n    for (let i = 1; i < length; ++i) {\n      if (x <= input[i]) {\n        narrowedInput = [input[i - 1], input[i], output[i - 1], output[i]];\n        break;\n      }\n    }\n  }\n  return internalInterpolate.apply({}, [x].concat(narrowedInput).concat(type));\n}\n"]},"metadata":{},"sourceType":"script"}